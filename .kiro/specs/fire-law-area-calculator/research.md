# 調査・設計決定

---
**目的**: 技術設計に影響を与える発見事項、アーキテクチャ調査、根拠を記録する。

**使用方法**:
- 発見フェーズ中の調査活動と結果を記録
- `design.md`には詳細すぎる設計決定のトレードオフを文書化
- 将来の監査や再利用のための参照と証拠を提供
---

## サマリー
- **機能**: `fire-law-area-calculator`
- **発見スコープ**: 新機能（グリーンフィールド）
- **主な発見事項**:
  - 消防法の面積計算に特化した単一ページWebアプリケーション
  - 複雑な階層データ構造（建物 > 階 > 用途 > 共用部グループ）
  - クライアントサイド完結型（外部API不要）
  - ローカルストレージによるデータ永続化（オプション）

## 調査ログ

### フロントエンド技術スタックの選定
- **コンテキスト**: 新規Webアプリケーションのため、モダンなフロントエンド技術が必要
- **検討した情報源**: 2024-2025年のフロントエンド動向、Reactエコシステムの現状
- **発見事項**:
  - **React 18+**: 最も広く採用されているUIライブラリ、豊富なエコシステム
  - **TypeScript**: 型安全性により複雑なデータ構造の管理が容易
  - **Vite**: 高速な開発サーバーとビルドツール
  - **状態管理**: useState/useReducerで十分（小規模アプリ）、必要に応じてZustand検討可能
- **影響**:
  - コンポーネント設計はReactのベストプラクティスに従う
  - TypeScriptによる厳密な型定義が必須
  - ビルド時間とHMRパフォーマンスの向上

### データ永続化戦略
- **コンテキスト**: Requirement 14でブラウザのローカルストレージによる保存が要求されている
- **検討した情報源**: Web Storage API、IndexedDB、localStorage制約
- **発見事項**:
  - **localStorage**: シンプルで十分（5-10MBの制限内で問題なし）
  - **データサイズ推定**: 1建物あたり最大10階×10用途×共用部グループ = 数KB程度
  - **シリアライゼーション**: JSON.stringify/parseで十分
- **影響**:
  - localStorage APIの直接使用で実装可能
  - 複数建物ケース保存のためにキー管理戦略が必要
  - データバージョニングを考慮（将来の機能拡張対応）

### UIコンポーネントライブラリの選定
- **コンテキスト**: レスポンシブでアクセシブルなUIが必要（Requirement 13）
- **検討した選択肢**:
  - **無し（純粋HTML/CSS）**: 完全な制御、学習コスト低
  - **Material-UI (MUI)**: 包括的、日本語対応良好
  - **Chakra UI**: モダン、アクセシビリティ優秀
- **選択**: 軽量アプローチ（TailwindCSS + Headless UI要素）
- **根拠**:
  - バンドルサイズ削減（パフォーマンス重視）
  - カスタマイズの柔軟性
  - 必要な機能のみを実装
- **影響**:
  - カスタムコンポーネント実装が必要
  - デザインシステムの一貫性を手動で管理

### 複数用途選択UIの実装パターン
- **コンテキスト**: Requirement 5, 13で任意の複数用途を選択する機能が必要
- **検討した選択肢**:
  1. チェックボックスリスト
  2. マルチセレクトドロップダウン
  3. ドラッグ&ドロップ選択
- **選択**: チェックボックスリスト + 視覚的グループ表示
- **根拠**:
  - 最もシンプルで直感的
  - モバイル対応が容易
  - 選択状態が常に可視化される
- **影響**:
  - 用途グループの視覚的表現が重要（色分け、ラベル表示）
  - 全用途選択の禁止バリデーションをUIレベルで実装

## アーキテクチャパターン評価

| オプション | 説明 | 強み | リスク/制限 | 備考 |
|--------|------|------|-----------|------|
| シンプルなReactコンポーネント階層 | 状態を親コンポーネントでリフトアップ、propsで子へ伝播 | 実装が直接的、デバッグが容易 | 階層が深くなるとprops drilling発生 | 小規模アプリには最適 |
| Context API + Hooks | React標準の状態共有メカニズム | 追加ライブラリ不要、props drilling回避 | 過度な使用でパフォーマンス低下 | 計算結果の共有に有用 |
| Zustand等の状態管理ライブラリ | グローバル状態の一元管理 | スケーラビリティ、明確な状態管理 | 小規模には過剰、学習コスト | 将来の拡張性を考慮する場合に検討 |

**選択**: シンプルなReactコンポーネント階層 + Context API（計算ロジックのみ）

## 設計決定

### 決定: データモデルの階層構造

- **コンテキスト**: 建物 > 階 > 用途 > 共用部グループという複雑な階層データを管理
- **検討した代替案**:
  1. フラットな構造 + IDリファレンス
  2. ネストされたオブジェクト構造
  3. 正規化されたテーブル構造（RDB風）
- **選択したアプローチ**: ネストされたオブジェクト構造
- **根拠**:
  - JSONとの親和性が高い（localStorage保存に最適）
  - TypeScriptの型定義が自然
  - UIのツリー構造と対応
  - 階単位の操作が容易
- **トレードオフ**:
  - 利点: 直感的、操作が簡単、シリアライゼーションが容易
  - 欠点: 深い更新操作が必要、不変性の維持に注意
- **フォローアップ**: Immerライブラリの検討（不変更新の簡素化）

### 決定: 計算ロジックの分離

- **コンテキスト**: 3種類の共用部案分計算という複雑なビジネスロジック
- **検討した代替案**:
  1. コンポーネント内に直接実装
  2. カスタムフックとして実装
  3. 純粋関数ライブラリとして分離
- **選択したアプローチ**: 純粋関数ライブラリ + カスタムフック
- **根拠**:
  - ユニットテストが容易（純粋関数）
  - 再利用性の向上
  - UIロジックとビジネスロジックの分離
- **トレードオフ**:
  - 利点: テスタビリティ、保守性、再利用性
  - 欠点: ファイル数増加、インポート管理
- **フォローアップ**: 計算精度のテストケース作成（小数点以下2桁の丸め処理）

### 決定: 用途グループの管理方法

- **コンテキスト**: 特定用途間の共用部は任意の複数用途の組み合わせを管理
- **検討した代替案**:
  1. 配列インデックスでの管理
  2. UUID生成による一意識別
  3. 用途IDの組み合わせをキーとする
- **選択したアプローチ**: UUID生成による一意識別
- **根拠**:
  - グループの追加・削除・編集が安全
  - 用途の順序変更に影響されない
  - リアクティブな更新が容易
- **トレードオフ**:
  - 利点: 安定性、予測可能性
  - 欠点: わずかなメモリオーバーヘッド
- **フォローアップ**: crypto.randomUUID()のブラウザ互換性確認

## リスクと軽減策

- **リスク1: 浮動小数点演算の精度誤差** 
  - 軽減策: 面積計算に`Decimal.js`等の精度ライブラリを使用、または整数演算（平方センチメートル単位）に変換
  
- **リスク2: 大量の階・用途データでのパフォーマンス低下**
  - 軽減策: 仮想スクロール（react-window）の導入検討、通常使用（10階以下）では問題なし
  
- **リスク3: ローカルストレージのクォータ超過**
  - 軽減策: データサイズ監視、古いケースの削除機能、警告表示

- **リスク4: 複雑な用途グループ選択UIのユーザビリティ**
  - 軽減策: プロトタイプでのユーザビリティテスト、明確な説明とツールチップの提供

## 参照
- [React 18 公式ドキュメント](https://react.dev/) — 最新のReactベストプラクティス
- [TypeScript Handbook](https://www.typescriptlang.org/docs/) — 型安全性のガイドライン
- [Web Storage API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API) — localStorage仕様
- [Vite](https://vitejs.dev/) — ビルドツール公式ドキュメント
